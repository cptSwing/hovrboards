/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { forwardRef, MutableRefObject, useEffect, useMemo } from 'react';
import { useGLTF } from '@react-three/drei';
import { Euler, Mesh, Object3D, Vector3 } from 'three';
import { GLTFResult, SocketTransforms } from '../../../types/types';

const BoardChubber = forwardRef<SocketTransforms>((props: JSX.IntrinsicElements['group'], socketRef) => {
    const { nodes } = useGLTF('/gltf/board_chubber.glb') as GLTFResult;

    const sockets_Memo = useMemo(() => {
        if (nodes) {
            const engineTemp: (Vector3 | Euler)[] = [];
            const hoverPadTemp: [string, Vector3, Euler][] = [];
            const ornamentTemp: [string, Vector3, Euler][] = [];

            nodes.board_chubber.traverse((node) => {
                if (node.name.includes('socket_')) {
                    if (node.name.includes('engine')) {
                        engineTemp.push(node.position, node.rotation);
                    }

                    if (node.name.includes('hoverpad')) {
                        hoverPadTemp.push([node.name, node.position, node.rotation]);
                    }

                    if (node.name.includes('ornament')) {
                        ornamentTemp.push([node.name, node.position, node.rotation]);
                    }
                }
            });

            hoverPadTemp.sort(([aName], [bName]) => (aName < bName ? -1 : aName > bName ? 1 : 0));
            ornamentTemp.sort(([aName], [bName]) => (aName < bName ? -1 : aName > bName ? 1 : 0));

            const engine = engineTemp as [Vector3, Euler];
            const hoverPads = hoverPadTemp.map(([_, vec3, euler]) => [vec3, euler]) as [Vector3, Euler][];
            const ornaments = ornamentTemp.map(([_, vec3, euler]) => [vec3, euler]) as [Vector3, Euler][];

            console.log('%c[BoardChubber]', 'color: #5f8e0f', `engine :`, engine);

            if (engine.length && hoverPads.length && ornaments.length) {
                return {
                    engine,
                    hoverPads,
                    ornaments,
                };
            } else return null;
        } else return null;
    }, [nodes]);

    useEffect(() => {
        if (socketRef) {
            (socketRef as MutableRefObject<SocketTransforms | null>).current = sockets_Memo;
        }

        console.log('%c[BoardChubber]', 'color: #243ce5', `socketRef :`, socketRef);
    }, [sockets_Memo]);

    return (
        <group {...props} dispose={null}>
            <mesh name='board_chubber' castShadow receiveShadow geometry={nodes.board_chubber.geometry} material={nodes.board_chubber.material} />
        </group>
    );
});

export default BoardChubber;

useGLTF.preload('/gltf/board_chubber.glb');

export const getFirstMesh = (nodes: GLTFResult['nodes']) => Object.values(nodes).find((node) => (node as Mesh).isMesh) as Mesh;
export const getFirstPlug = (nodes: GLTFResult['nodes']) => Object.values(nodes).find((node) => node.name.includes('plug_')) as Object3D;
